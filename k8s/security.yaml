# 网络策略 - 默认拒绝所有流量
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: default-deny-all
  namespace: medical-ai
spec:
  podSelector: {}
  policyTypes:
  - Ingress
  - Egress
---
# 网络策略 - 允许前端到后端的通信
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-frontend-to-backend
  namespace: medical-ai
spec:
  podSelector:
    matchLabels:
      app: medical-ai-backend
  policyTypes:
  - Ingress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          app: nginx-frontend
    ports:
    - protocol: TCP
      port: 8000
---
# 网络策略 - 允许后端到数据库的通信
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-backend-to-database
  namespace: medical-ai
spec:
  podSelector:
    matchLabels:
      app: postgres
  policyTypes:
  - Ingress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          app: medical-ai-backend
    - podSelector:
        matchLabels:
          app: ai-inference
    ports:
    - protocol: TCP
      port: 5432
---
# 网络策略 - 允许后端到Redis的通信
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-backend-to-redis
  namespace: medical-ai
spec:
  podSelector:
    matchLabels:
      app: redis
  policyTypes:
  - Ingress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          app: medical-ai-backend
    - podSelector:
        matchLabels:
          app: celery-worker
    ports:
    - protocol: TCP
      port: 6379
---
# 网络策略 - 允许监控系统访问
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-monitoring
  namespace: medical-ai
spec:
  podSelector:
    matchLabels:
      monitoring: "true"
  policyTypes:
  - Ingress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          app: prometheus
    ports:
    - protocol: TCP
      port: 9090
    - protocol: TCP
      port: 9091
    - protocol: TCP
      port: 9113
---
# 网络策略 - 允许DNS解析
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-dns
  namespace: medical-ai
spec:
  podSelector: {}
  policyTypes:
  - Egress
  egress:
  - to: []
    ports:
    - protocol: UDP
      port: 53
    - protocol: TCP
      port: 53
---
# Pod安全策略
apiVersion: policy/v1beta1
kind: PodSecurityPolicy
metadata:
  name: medical-ai-psp
spec:
  privileged: false
  allowPrivilegeEscalation: false
  requiredDropCapabilities:
    - ALL
  volumes:
    - 'configMap'
    - 'emptyDir'
    - 'projected'
    - 'secret'
    - 'downwardAPI'
    - 'persistentVolumeClaim'
  hostNetwork: false
  hostIPC: false
  hostPID: false
  runAsUser:
    rule: 'MustRunAsNonRoot'
  supplementalGroups:
    rule: 'MustRunAs'
    ranges:
      - min: 1
        max: 65535
  fsGroup:
    rule: 'MustRunAs'
    ranges:
      - min: 1
        max: 65535
  readOnlyRootFilesystem: false
  seLinux:
    rule: 'RunAsAny'
---
# ServiceAccount for applications
apiVersion: v1
kind: ServiceAccount
metadata:
  name: medical-ai-app
  namespace: medical-ai
automountServiceAccountToken: false
---
# Role for application pods
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: medical-ai
  name: medical-ai-app-role
rules:
- apiGroups: [""]
  resources: ["configmaps", "secrets"]
  verbs: ["get", "list"]
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "list"]
---
# RoleBinding for application
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: medical-ai-app-binding
  namespace: medical-ai
subjects:
- kind: ServiceAccount
  name: medical-ai-app
  namespace: medical-ai
roleRef:
  kind: Role
  name: medical-ai-app-role
  apiGroup: rbac.authorization.k8s.io
---
# ServiceAccount for monitoring
apiVersion: v1
kind: ServiceAccount
metadata:
  name: medical-ai-monitoring
  namespace: medical-ai
---
# ClusterRole for monitoring
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: medical-ai-monitoring
rules:
- apiGroups: [""]
  resources:
  - nodes
  - nodes/proxy
  - services
  - endpoints
  - pods
  verbs: ["get", "list", "watch"]
- apiGroups:
  - extensions
  resources:
  - ingresses
  verbs: ["get", "list", "watch"]
- nonResourceURLs: ["/metrics"]
  verbs: ["get"]
---
# ClusterRoleBinding for monitoring
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: medical-ai-monitoring
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: medical-ai-monitoring
subjects:
- kind: ServiceAccount
  name: medical-ai-monitoring
  namespace: medical-ai
---
# 安全扫描 - Falco配置
apiVersion: v1
kind: ConfigMap
metadata:
  name: falco-config
  namespace: medical-ai
data:
  falco.yaml: |
    rules_file:
      - /etc/falco/falco_rules.yaml
      - /etc/falco/falco_rules.local.yaml
      - /etc/falco/k8s_audit_rules.yaml
      - /etc/falco/rules.d
    
    time_format_iso_8601: true
    json_output: true
    json_include_output_property: true
    json_include_tags_property: true
    
    log_stderr: true
    log_syslog: true
    log_level: info
    
    priority: debug
    
    buffered_outputs: false
    
    syscall_event_drops:
      actions:
        - log
        - alert
      rate: 0.03333
      max_burst: 1000
    
    outputs:
      rate: 1
      max_burst: 1000
    
    syslog_output:
      enabled: true
    
    file_output:
      enabled: true
      keep_alive: false
      filename: /var/log/falco.log
    
    stdout_output:
      enabled: true
    
    webserver:
      enabled: true
      listen_port: 8765
      k8s_healthz_endpoint: /healthz
      ssl_enabled: false
    
    grpc:
      enabled: false
      bind_address: "0.0.0.0:5060"
      threadiness: 0
    
    grpc_output:
      enabled: false
  
  falco_rules.local.yaml: |
    # Medical AI specific rules
    - rule: Unauthorized Access to Medical Data
      desc: Detect unauthorized access to medical data directories
      condition: >
        open_read and
        fd.name startswith /data/medical/ and
        not proc.name in (medical-ai-backend, ai-inference, postgres)
      output: >
        Unauthorized access to medical data
        (user=%user.name command=%proc.cmdline file=%fd.name)
      priority: CRITICAL
      tags: [medical_data, unauthorized_access]
    
    - rule: Suspicious AI Model Access
      desc: Detect suspicious access to AI model files
      condition: >
        open_read and
        fd.name startswith /models/ and
        not proc.name in (ai-inference, medical-ai-backend)
      output: >
        Suspicious AI model access
        (user=%user.name command=%proc.cmdline file=%fd.name)
      priority: WARNING
      tags: [ai_models, suspicious_access]
    
    - rule: Database Connection from Unauthorized Process
      desc: Detect database connections from unauthorized processes
      condition: >
        outbound and
        fd.sport=5432 and
        not proc.name in (medical-ai-backend, ai-inference, celery-worker)
      output: >
        Unauthorized database connection
        (user=%user.name command=%proc.cmdline connection=%fd.name)
      priority: CRITICAL
      tags: [database, unauthorized_connection]
    
    - rule: Privilege Escalation Attempt
      desc: Detect privilege escalation attempts
      condition: >
        spawned_process and
        proc.name in (sudo, su, setuid) and
        container.id != host
      output: >
        Privilege escalation attempt in container
        (user=%user.name command=%proc.cmdline container=%container.name)
      priority: CRITICAL
      tags: [privilege_escalation, container_security]
    
    - rule: Sensitive File Access
      desc: Detect access to sensitive configuration files
      condition: >
        open_read and
        fd.name in (/etc/passwd, /etc/shadow, /etc/ssh/ssh_host_rsa_key) and
        not proc.name in (sshd, systemd)
      output: >
        Sensitive file access detected
        (user=%user.name command=%proc.cmdline file=%fd.name)
      priority: WARNING
      tags: [sensitive_files, security]
---
# Falco DaemonSet
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: falco
  namespace: medical-ai
spec:
  selector:
    matchLabels:
      app: falco
  template:
    metadata:
      labels:
        app: falco
    spec:
      serviceAccountName: falco
      hostNetwork: true
      hostPID: true
      containers:
      - name: falco
        image: falcosecurity/falco:0.36.2
        securityContext:
          privileged: true
        args:
          - /usr/bin/falco
          - --cri=/run/containerd/containerd.sock
          - --k8s-api=https://kubernetes.default:443
          - --k8s-api-cert=/var/run/secrets/kubernetes.io/serviceaccount/ca.crt
          - --k8s-api-token=/var/run/secrets/kubernetes.io/serviceaccount/token
        env:
        - name: FALCO_K8S_NODE_NAME
          valueFrom:
            fieldRef:
              fieldPath: spec.nodeName
        volumeMounts:
        - mountPath: /host/var/run/docker.sock
          name: docker-socket
        - mountPath: /host/run/containerd/containerd.sock
          name: containerd-socket
        - mountPath: /host/dev
          name: dev-fs
        - mountPath: /host/proc
          name: proc-fs
          readOnly: true
        - mountPath: /host/boot
          name: boot-fs
          readOnly: true
        - mountPath: /host/lib/modules
          name: lib-modules
          readOnly: true
        - mountPath: /host/usr
          name: usr-fs
          readOnly: true
        - mountPath: /host/etc
          name: etc-fs
          readOnly: true
        - mountPath: /etc/falco
          name: falco-config
        resources:
          requests:
            cpu: 100m
            memory: 512Mi
          limits:
            cpu: 1000m
            memory: 1Gi
      volumes:
      - name: docker-socket
        hostPath:
          path: /var/run/docker.sock
      - name: containerd-socket
        hostPath:
          path: /run/containerd/containerd.sock
      - name: dev-fs
        hostPath:
          path: /dev
      - name: proc-fs
        hostPath:
          path: /proc
      - name: boot-fs
        hostPath:
          path: /boot
      - name: lib-modules
        hostPath:
          path: /lib/modules
      - name: usr-fs
        hostPath:
          path: /usr
      - name: etc-fs
        hostPath:
          path: /etc
      - name: falco-config
        configMap:
          name: falco-config
      tolerations:
      - effect: NoSchedule
        key: node-role.kubernetes.io/master
---
# Falco ServiceAccount
apiVersion: v1
kind: ServiceAccount
metadata:
  name: falco
  namespace: medical-ai
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: falco
rules:
- apiGroups: [""]
  resources: ["nodes", "namespaces", "pods", "replicationcontrollers", "replicasets", "services", "daemonsets", "deployments", "events", "configmaps"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["apps"]
  resources: ["daemonsets", "deployments", "replicasets", "statefulsets"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["extensions"]
  resources: ["daemonsets", "deployments", "replicasets"]
  verbs: ["get", "list", "watch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: falco
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: falco
subjects:
- kind: ServiceAccount
  name: falco
  namespace: medical-ai
---
# 镜像安全扫描 - Trivy Operator
apiVersion: v1
kind: ConfigMap
metadata:
  name: trivy-operator-config
  namespace: medical-ai
data:
  trivy.repository: "ghcr.io/aquasecurity/trivy"
  trivy.tag: "0.47.0"
  trivy.severity: "UNKNOWN,LOW,MEDIUM,HIGH,CRITICAL"
  trivy.slow: "true"
  trivy.dbRepository: "ghcr.io/aquasecurity/trivy-db"
  trivy.javaDbRepository: "ghcr.io/aquasecurity/trivy-java-db"
  compliance.failEntriesLimit: "10"
  vulnerabilityReports.scanner: "Trivy"
  configAuditReports.scanner: "Trivy"
  report.recordFailedChecksOnly: "true"
  metrics.resourceLabelsPrefix: "trivy.resource.labels"
---
# OPA Gatekeeper约束模板
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: k8srequiredsecuritycontext
spec:
  crd:
    spec:
      names:
        kind: K8sRequiredSecurityContext
      validation:
        type: object
        properties:
          runAsNonRoot:
            type: boolean
          readOnlyRootFilesystem:
            type: boolean
          allowPrivilegeEscalation:
            type: boolean
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8srequiredsecuritycontext
        
        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          not container.securityContext.runAsNonRoot
          msg := "Container must run as non-root user"
        }
        
        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          not container.securityContext.readOnlyRootFilesystem
          msg := "Container must have read-only root filesystem"
        }
        
        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          container.securityContext.allowPrivilegeEscalation
          msg := "Container must not allow privilege escalation"
        }
---
# 应用安全上下文约束
apiVersion: constraints.gatekeeper.sh/v1beta1
kind: K8sRequiredSecurityContext
metadata:
  name: must-have-security-context
spec:
  match:
    kinds:
      - apiGroups: ["apps"]
        kinds: ["Deployment"]
    namespaces: ["medical-ai"]
  parameters:
    runAsNonRoot: true
    readOnlyRootFilesystem: true
    allowPrivilegeEscalation: false
---
# 资源配额约束
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: k8srequiredresources
spec:
  crd:
    spec:
      names:
        kind: K8sRequiredResources
      validation:
        type: object
        properties:
          limits:
            type: array
            items:
              type: string
          requests:
            type: array
            items:
              type: string
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8srequiredresources
        
        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          required := input.parameters.limits
          missing := required[_]
          not container.resources.limits[missing]
          msg := sprintf("Container is missing required resource limit: %v", [missing])
        }
        
        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          required := input.parameters.requests
          missing := required[_]
          not container.resources.requests[missing]
          msg := sprintf("Container is missing required resource request: %v", [missing])
        }
---
apiVersion: constraints.gatekeeper.sh/v1beta1
kind: K8sRequiredResources
metadata:
  name: must-have-resources
spec:
  match:
    kinds:
      - apiGroups: ["apps"]
        kinds: ["Deployment"]
    namespaces: ["medical-ai"]
  parameters:
    limits: ["memory", "cpu"]
    requests: ["memory", "cpu"]